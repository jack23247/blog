---
title: "Decoding Rotary Quadrature Encoders in Software"
date: 2024-05-29T13:20:00+02:00 ## date +%Y-%m-%dT%H:%M:%S%z
categories:
 - embedded
tags:
 - encoder
 - coderbot
 - hardware
 - software
---

Rotary Quadrature Encoders (RQEs) are a particular type of incremental encoder that utilize two out-of-phase channels to carry information about the direction and speed of motion of a rotating shaft, such as the output of a motor or the scrolling of a mouse wheel's axis.

## Building an RQE

The RQE uses a combination of an indexing disk and two sets of sensor to produce two square-wave signals: the sensors must be placed far enough from each other so that the two waves will be $\pm90°$ out-of-phase when the speed of the measured shaft is constant (hence the term "Quadrature"). Such a device may be built using LEDs, photodiodes, and an indexing disk to create pulses, or by placing hall effect sensors near a magnetized disk and looking at magnetic flux changes as the disk rotates.

The pictures below show a Magnetic and an Optical RQE. In the first picture, the two angled ICs placed on the bottom part of the PCB are the Hall Effect Sensors, while in the second picture, the two plastic fixtures with wires house the photodiodes and the LEDs.

<img src="https://www.prohobi.net/ps2018/761-large_default/magnetic-encoder-pair-kit-for-micro-metal-gearmotors-12-cpr.jpg" alt="magnetic-rqd" style="width: 20em;" />


<img src="https://electronics360.globalspec.com/images/assets/289/11289/Encoder.jpg" alt="optical-rqe" style="width: 30em;" />


## Encoding Speed and Direction

If we simply wanted to measure a device's rotational speed, using an RQE would be overkill: a single indexing hole and a photodiode would suffice[^1], as an impulse would be generated each time the indexing hole passes over the sensor; the speed can be derived from this signal by measuring the frequency of the resulting square wave.

[^1]: This method was, for example, used in 5¼" floppy disk drives to measure the speed of rotation of the medium.

This simplistic approach, however, has a few drawbacks:

1. **Low granularity** - Having a single index hole across a circumference means infrequent and potentially inconsistent updates if the "spinny bits" experience sudden changes in velocity or direction, which can only be inferred by looking at how the last $n$ speed measurements differ from each other. This can be remedied by adding more evenly-spaced indexing holes across the circumference of the measured device, keeping in mind to divide the frequency of the resulting square wave by the number of indexing holes to obtain the effective rate of rotation.
2. **No directionality** - While adding more indexing holes can help with granularity, it won't be enough if the application needs to determine the direction of rotation, as the pulses generated while moving in either direction will be indistinguishable from each other. RQEs solve this problem by adding a second channel which, by construction, is guaranteed to be $\pm90°$ out-of-phase from the first one: this property allows us to easily determine the direction of rotation by looking at which channel is *leading* (i.e. produces the first impulse).

The following animations show how rotation is encoded using two sensors and an indexing disk.

<img src="https://lastminuteengineers.b-cdn.net/wp-content/uploads/arduino/rotary-encoder-working-animation.gif" alt="rotary-enc-gif" style="width: 35em;" />

<img src="https://raw.githubusercontent.com/jack23247/blog/master/img/enc-chan.gif" alt="chan-gif" style="width: 25em;" />

## Decoding an RQE in software

While many modern microcontrollers provide hardware units capable of decoding high-frequency Quadrature signals without CPU intervention[^2], other commonly available devices that only have GPIO ports at their disposal can be used to decode signals generated by an RQE in software as long as the frequency of the square waves isn't prohibitive.

[^2]: The STMicroelectronics MCUs, for example, allow the programmer to use a timer as a Quadrature decoder. Source: [STM32G4 GPTIM Presentation Notes pp.10-17](https://www.st.com/resource/en/product_training/STM32G4-WDG_TIMERS-General_Purpose_Timer_GPTIM.pdf)

The [CoderBot platform](https://dev.coderbot.org/), for example, uses a Raspberry Pi 3 to control a small robot using two independent wheels; speed and direction of each wheel is tracked by a magnetic RQE placed on the output shaft of the motor. The encoder has 16 steps per revolution and the wheel uses a 1:120 transmission ratio. Each encoder's A and B channels are directly connected to a GPIO input on the Raspberry Pi; the corresponding pins are used as inputs and a callback function is registered when an edge is detected using the [`libpigpio`](https://abyz.me.uk/rpi/pigpio/cif.html#gpioSetISRFuncEx) library.

A state machine can be used to represent the Quadrature signal at any time; if we use a 2-bit word to represent the two channels, where channel A is the MSB, the following state transitions apply.

<img src="https://raw.githubusercontent.com/jack23247/blog/master/img/fsm_rqe.png" alt="fsm-rqe" style="width: 20em;" />

If channel A *leads* channel B, the motor is spinning clockwise[^3], and vice versa. Transition between states `00` and `11`, and between `10` and `01` are not valid: this can be easily detected by ensuring that only one bit changes at a time. Moreover, since we're only interested in counting full ticks (i.e. the number of peaks, which is equivalent to the number of rising edges) we only register a tick when the channels show different logic levels by XORing the two channels and incrementing or decrementing the number of ticks, depending on the direction, only if they do.

[^3]: We may say clockwise, but it really depends on how the sensors are wired.

```c 
// Channel A ISR
if(chan_a ^ chan_b) { // Either one of A or B is 1 
    direction = FORWARD;
    ticks = ticks + 1;  
} else {
    ; // Don't register ticks
}
```

```c 
// Channel B ISR
if(chan_a ^ chan_b) { // Either one of A or B is 1 
    direction = BACKWARD;
    ticks = ticks - 1;  
} else {
    ; // Don't register ticks
}
```

When a pulse is received and handled, debouncing must be taken into account: since more than one interrupt can be generated when the square transitions from one logic level to another, due to various factors, the routine must ignore repeated signals from the same channel. 

```c
if(last_chan != cur_chan) { // Ensure last interrupt didn't come from current Channel
	// Count ticks, etc.
} else {
	return; // Debounce
}
```

The [`libcoderbot`](https://github.com/jack23247/libcoderbot/blob/main/src/encoder.c) library provides an implementation of the decoder.